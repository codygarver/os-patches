Description: Make airplane mode switch everything off by using /dev/rfkill
Author: Bastien Nocera <hadess@hadess.net>
Origin: upstream, commit: 7aef2fb307a9ff9c32fbe9dc6bc36e1eef5e72ab

Index: b/panels/network/Makefile.am
===================================================================
--- a/panels/network/Makefile.am
+++ b/panels/network/Makefile.am
@@ -31,7 +31,10 @@
 	network-dialogs.c				\
 	network-dialogs.h				\
 	cc-network-panel.c				\
-	cc-network-panel.h
+	cc-network-panel.h				\
+	rfkill-glib.c					\
+	rfkill-glib.h					\
+	rfkill.h
 
 libnetwork_la_LIBADD = $(PANEL_LIBS) $(NETWORK_PANEL_LIBS) $(NETWORK_MANAGER_LIBS)
 libnetwork_la_LDFLAGS = $(PANEL_LDFLAGS)
Index: b/panels/network/cc-network-panel.c
===================================================================
--- a/panels/network/cc-network-panel.c
+++ b/panels/network/cc-network-panel.c
@@ -50,6 +50,8 @@
 #include "net-device.h"
 #include "net-vpn.h"
 
+#include "rfkill-glib.h"
+
 #include "panel-common.h"
 #include "panel-cell-renderer-mode.h"
 #include "panel-cell-renderer-signal.h"
@@ -82,7 +84,12 @@
         guint             add_header_widgets_idle;
         guint             nm_warning_idle;
         guint             refresh_idle;
+
+        /* Killswitch stuff */
         GtkWidget        *kill_switch_header;
+        RfkillGlib       *rfkill;
+        GtkSwitch        *rfkill_switch;
+        GHashTable       *killswitches;
 
         /* wireless dialog stuff */
         CmdlineOperation  arg_operation;
@@ -215,6 +222,14 @@
         if (priv->kill_switch_header != NULL) {
                 g_clear_object (&priv->kill_switch_header);
         }
+        if (priv->rfkill != NULL) {
+                g_clear_object (&priv->rfkill);
+        }
+        if (priv->killswitches != NULL) {
+                g_hash_table_destroy (&priv->killswitches);
+                priv->killswitches = NULL;
+        }
+        priv->rfkill_switch = NULL;
         if (priv->refresh_idle != 0) {
                 g_source_remove (priv->refresh_idle);
                 priv->refresh_idle = 0;
@@ -2294,10 +2309,17 @@
                                           CcNetworkPanel *panel)
 {
         gboolean enable;
+        struct rfkill_event event;
+
+        enable = gtk_switch_get_active (sw);
+        g_debug ("Setting killswitch to %d", enable);
 
-        /* set enabled state */
-        enable = !gtk_switch_get_active (sw);
-        nm_client_wireless_set_enabled (panel->priv->client, enable);
+        memset (&event, 0, sizeof(event));
+        event.op = RFKILL_OP_CHANGE_ALL;
+        event.type = RFKILL_TYPE_ALL;
+        event.soft = enable ? 1 : 0;
+        if (rfkill_glib_send_event (panel->priv->rfkill, &event) < 0)
+                g_warning ("Setting the killswitch %s failed", enable ? "on" : "off");
 }
 
 static void
@@ -2791,6 +2813,60 @@
 }
 
 static void
+rfkill_changed (RfkillGlib     *rfkill,
+                GList          *events,
+                CcNetworkPanel *panel)
+{
+        gboolean enabled;
+        GList *l;
+        GHashTableIter iter;
+        gpointer key, value;
+
+        enabled = TRUE;
+
+        for (l = events; l != NULL; l = l->next) {
+                struct rfkill_event *event = l->data;
+
+                if (event->op == RFKILL_OP_ADD)
+                        g_hash_table_insert (panel->priv->killswitches,
+                                             GINT_TO_POINTER (event->idx),
+                                             GINT_TO_POINTER (event->soft || event->hard));
+                else if (event->op == RFKILL_OP_CHANGE)
+                        g_hash_table_insert (panel->priv->killswitches,
+                                             GINT_TO_POINTER (event->idx),
+                                             GINT_TO_POINTER (event->soft || event->hard));
+                else if (event->op == RFKILL_OP_DEL)
+                        g_hash_table_remove (panel->priv->killswitches,
+                                             GINT_TO_POINTER (event->idx));
+        }
+
+        g_hash_table_iter_init (&iter, panel->priv->killswitches);
+        while (g_hash_table_iter_next (&iter, &key, &value)) {
+                int idx, state;
+
+                idx = GPOINTER_TO_INT (key);
+                state = GPOINTER_TO_INT (value);
+                g_debug ("Killswitch %d is %s", idx, state ? "enabled" : "disabled");
+
+                /* A single device that's enabled? airplane mode is off */
+                if (state == FALSE) {
+                        enabled = FALSE;
+                        break;
+                }
+        }
+
+        if (enabled != gtk_switch_get_active (panel->priv->rfkill_switch)) {
+                g_signal_handlers_block_by_func (panel->priv->rfkill_switch,
+                                                 cc_network_panel_notify_enable_active_cb,
+                                                 panel);
+                gtk_switch_set_active (panel->priv->rfkill_switch, enabled);
+                g_signal_handlers_unblock_by_func (panel->priv->rfkill_switch,
+                                                   cc_network_panel_notify_enable_active_cb,
+                                                   panel);
+        }
+}
+
+static void
 connection_activate_cb (NMClient *client,
                         NMActiveConnection *connection,
                         GError *error,
@@ -3356,7 +3432,6 @@
 network_add_shell_header_widgets_cb (gpointer user_data)
 {
         CcNetworkPanel *panel = CC_NETWORK_PANEL (user_data);
-        gboolean ret;
         GtkWidget *box;
         GtkWidget *widget;
 
@@ -3369,12 +3444,18 @@
         widget = gtk_switch_new ();
         gtk_box_pack_start (GTK_BOX (box), widget, FALSE, FALSE, 0);
         gtk_widget_set_visible (widget, TRUE);
+        panel->priv->rfkill_switch = GTK_SWITCH (widget);
         cc_shell_embed_widget_in_header (cc_panel_get_shell (CC_PANEL (panel)), box);
         panel->priv->kill_switch_header = g_object_ref (box);
 
-        ret = nm_client_wireless_get_enabled (panel->priv->client);
-        gtk_switch_set_active (GTK_SWITCH (widget), !ret);
-        g_signal_connect (GTK_SWITCH (widget), "notify::active",
+        panel->priv->killswitches = g_hash_table_new (g_direct_hash, g_direct_equal);
+        panel->priv->rfkill = rfkill_glib_new ();
+        g_signal_connect (G_OBJECT (panel->priv->rfkill), "changed",
+                          G_CALLBACK (rfkill_changed), panel);
+        if (rfkill_glib_open (panel->priv->rfkill) < 0)
+                gtk_widget_hide (box);
+
+        g_signal_connect (panel->priv->rfkill_switch, "notify::active",
                           G_CALLBACK (cc_network_panel_notify_enable_active_cb),
                           panel);
         panel_refresh_killswitch_visibility (panel);
Index: b/panels/network/rfkill-glib.c
===================================================================
--- /dev/null
+++ b/panels/network/rfkill-glib.c
@@ -0,0 +1,299 @@
+/*
+ *
+ *  gnome-bluetooth - Bluetooth integration for GNOME
+ *
+ *  Copyright (C) 2012  Bastien Nocera <hadess@hadess.net>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include "rfkill-glib.h"
+
+enum {
+	CHANGED,
+	LAST_SIGNAL
+};
+
+static int signals[LAST_SIGNAL] = { 0 };
+
+#define RFKILL_GLIB_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), \
+				RFKILL_TYPE_GLIB, RfkillGlibPrivate))
+
+struct RfkillGlibPrivate {
+	int fd;
+	GIOChannel *channel;
+	guint watch_id;
+};
+
+G_DEFINE_TYPE(RfkillGlib, rfkill_glib, G_TYPE_OBJECT)
+
+int
+rfkill_glib_send_event (RfkillGlib *rfkill, struct rfkill_event *event)
+{
+	g_return_val_if_fail (RFKILL_IS_GLIB (rfkill), -1);
+	g_return_val_if_fail (rfkill->priv->fd > 0, -1);
+
+	return write (rfkill->priv->fd, event, sizeof(struct rfkill_event));
+}
+
+static const char *
+type_to_string (unsigned int type)
+{
+	switch (type) {
+	case RFKILL_TYPE_ALL:
+		return "ALL";
+	case RFKILL_TYPE_WLAN:
+		return "WLAN";
+	case RFKILL_TYPE_BLUETOOTH:
+		return "RFKILL";
+	case RFKILL_TYPE_UWB:
+		return "UWB";
+	case RFKILL_TYPE_WIMAX:
+		return "WIMAX";
+	case RFKILL_TYPE_WWAN:
+		return "WWAN";
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+static const char *
+op_to_string (unsigned int op)
+{
+	switch (op) {
+	case RFKILL_OP_ADD:
+		return "ADD";
+	case RFKILL_OP_DEL:
+		return "DEL";
+	case RFKILL_OP_CHANGE:
+		return "CHANGE";
+	case RFKILL_OP_CHANGE_ALL:
+		return "CHANGE_ALL";
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+static void
+print_event (struct rfkill_event *event)
+{
+	g_debug ("RFKILL event: idx %u type %u (%s) op %u (%s) soft %u hard %u",
+		 event->idx,
+		 event->type, type_to_string (event->type),
+		 event->op, op_to_string (event->op),
+		 event->soft, event->hard);
+}
+
+static void
+emit_changed_signal_and_free (RfkillGlib *rfkill,
+			      GList      *events)
+{
+	if (events == NULL)
+		return;
+
+	g_signal_emit (G_OBJECT (rfkill),
+		       signals[CHANGED],
+		       0, events);
+	g_list_free_full (events, g_free);
+}
+
+static gboolean
+event_cb (GIOChannel   *source,
+	  GIOCondition  condition,
+	  RfkillGlib   *rfkill)
+{
+	GList *events;
+
+	events = NULL;
+
+	if (condition & G_IO_IN) {
+		GIOStatus status;
+		struct rfkill_event event;
+		gsize read;
+
+		status = g_io_channel_read_chars (source,
+						  (char *) &event,
+						  sizeof(event),
+						  &read,
+						  NULL);
+
+		while (status == G_IO_STATUS_NORMAL && read == sizeof(event)) {
+			struct rfkill_event *event_ptr;
+
+			print_event (&event);
+
+			event_ptr = g_memdup (&event, sizeof(event));
+			events = g_list_prepend (events, event_ptr);
+
+			status = g_io_channel_read_chars (source,
+							  (char *) &event,
+							  sizeof(event),
+							  &read,
+							  NULL);
+		}
+		events = g_list_reverse (events);
+	} else {
+		g_debug ("something else happened");
+		return FALSE;
+	}
+
+	emit_changed_signal_and_free (rfkill, events);
+
+	return TRUE;
+}
+
+static void
+rfkill_glib_init (RfkillGlib *rfkill)
+{
+	RfkillGlibPrivate *priv;
+
+	priv = RFKILL_GLIB_GET_PRIVATE (rfkill);
+	rfkill->priv = priv;
+	rfkill->priv->fd = -1;
+}
+
+int
+rfkill_glib_open (RfkillGlib *rfkill)
+{
+	RfkillGlibPrivate *priv;
+	int fd;
+	int ret;
+	GList *events;
+
+	g_return_val_if_fail (RFKILL_IS_GLIB (rfkill), -1);
+	g_return_val_if_fail (rfkill->priv->fd == -1, -1);
+
+	priv = rfkill->priv;
+
+	fd = open("/dev/rfkill", O_RDWR);
+	if (fd < 0) {
+		if (errno == EACCES)
+			g_warning ("Could not open RFKILL control device, please verify your installation");
+		return fd;
+	}
+
+	ret = fcntl(fd, F_SETFL, O_NONBLOCK);
+	if (ret < 0) {
+		g_debug ("Can't set RFKILL control device to non-blocking");
+		close(fd);
+		return ret;
+	}
+
+	events = NULL;
+
+	while (1) {
+		struct rfkill_event event;
+		struct rfkill_event *event_ptr;
+		ssize_t len;
+
+		len = read(fd, &event, sizeof(event));
+		if (len < 0) {
+			if (errno == EAGAIN)
+				break;
+			g_debug ("Reading of RFKILL events failed");
+			break;
+		}
+
+		if (len != RFKILL_EVENT_SIZE_V1) {
+			g_warning ("Wrong size of RFKILL event\n");
+			continue;
+		}
+
+		if (event.op != RFKILL_OP_ADD)
+			continue;
+
+		g_debug ("Read killswitch of type '%s' (idx=%d): soft %d hard %d",
+			 type_to_string (event.type),
+			 event.idx, event.soft, event.hard);
+
+		event_ptr = g_memdup (&event, sizeof(event));
+		events = g_list_prepend (events, event_ptr);
+	}
+
+	/* Setup monitoring */
+	priv->fd = fd;
+	priv->channel = g_io_channel_unix_new (priv->fd);
+	priv->watch_id = g_io_add_watch (priv->channel,
+					 G_IO_IN | G_IO_HUP | G_IO_ERR,
+					 (GIOFunc) event_cb,
+					 rfkill);
+
+	events = g_list_reverse (events);
+	emit_changed_signal_and_free (rfkill, events);
+
+	return fd;
+}
+
+static void
+rfkill_glib_finalize (GObject *object)
+{
+	RfkillGlib *rfkill;
+	RfkillGlibPrivate *priv;
+
+	rfkill = RFKILL_GLIB (object);
+	priv = rfkill->priv;
+
+	/* cleanup monitoring */
+	if (priv->watch_id > 0) {
+		g_source_remove (priv->watch_id);
+		priv->watch_id = 0;
+		g_io_channel_shutdown (priv->channel, FALSE, NULL);
+		g_io_channel_unref (priv->channel);
+	}
+	close(priv->fd);
+	priv->fd = -1;
+
+	G_OBJECT_CLASS(rfkill_glib_parent_class)->finalize(object);
+}
+
+static void
+rfkill_glib_class_init(RfkillGlibClass *klass)
+{
+	GObjectClass *object_class = (GObjectClass *) klass;
+
+	g_type_class_add_private(klass, sizeof(RfkillGlibPrivate));
+	object_class->finalize = rfkill_glib_finalize;
+
+	signals[CHANGED] =
+		g_signal_new ("changed",
+			      G_TYPE_FROM_CLASS (klass),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (RfkillGlibClass, changed),
+			      NULL, NULL,
+			      NULL,
+			      G_TYPE_NONE, 1, G_TYPE_POINTER);
+
+}
+
+RfkillGlib *
+rfkill_glib_new (void)
+{
+	return RFKILL_GLIB (g_object_new (RFKILL_TYPE_GLIB, NULL));
+}
Index: b/panels/network/rfkill-glib.h
===================================================================
--- /dev/null
+++ b/panels/network/rfkill-glib.h
@@ -0,0 +1,65 @@
+/*
+ *
+ *  gnome-bluetooth - Bluetooth integration for GNOME
+ *
+ *  Copyright (C) 2012  Bastien Nocera <hadess@hadess.net>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __RFKILL_GLIB_H
+#define __RFKILL_GLIB_H
+
+#include <glib-object.h>
+#include "rfkill.h"
+
+G_BEGIN_DECLS
+
+#define RFKILL_TYPE_GLIB (rfkill_glib_get_type())
+#define RFKILL_GLIB(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
+		RFKILL_TYPE_GLIB, RfkillGlib))
+#define RFKILL_GLIB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), \
+		RFKILL_TYPE_GLIB, RfkillGlibClass))
+#define RFKILL_IS_GLIB(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), \
+		RFKILL_TYPE_GLIB))
+#define RFKILL_IS_GLIB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), \
+		RFKILL_TYPE_GLIB))
+#define RFKILL_GET_GLIB_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), \
+		RFKILL_TYPE_GLIB, RfkillGlibClass))
+
+typedef struct RfkillGlibPrivate RfkillGlibPrivate;
+
+typedef struct _RfkillGlib {
+	GObject parent;
+	RfkillGlibPrivate *priv;
+} RfkillGlib;
+
+typedef struct _RfkillGlibClass {
+	GObjectClass parent_class;
+
+	void (*changed) (RfkillGlib *rfkill, GList *events);
+} RfkillGlibClass;
+
+GType rfkill_glib_get_type(void);
+
+RfkillGlib *rfkill_glib_new (void);
+int rfkill_glib_open (RfkillGlib *rfkill);
+int rfkill_glib_send_event (RfkillGlib *rfkill, struct rfkill_event *event);
+
+G_END_DECLS
+
+#endif /* __RFKILL_GLIB_H */
Index: b/panels/network/rfkill.h
===================================================================
--- /dev/null
+++ b/panels/network/rfkill.h
@@ -0,0 +1,107 @@
+#ifndef __RFKILL_H
+#define __RFKILL_H
+
+/*
+ * Copyright (C) 2006 - 2007 Ivo van Doorn
+ * Copyright (C) 2007 Dmitry Torokhov
+ * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+
+/* define userspace visible states */
+#define RFKILL_STATE_SOFT_BLOCKED	0
+#define RFKILL_STATE_UNBLOCKED		1
+#define RFKILL_STATE_HARD_BLOCKED	2
+
+/**
+ * enum rfkill_type - type of rfkill switch.
+ *
+ * @RFKILL_TYPE_ALL: toggles all switches (requests only - not a switch type)
+ * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
+ * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
+ * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
+ * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
+ * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
+ * @RFKILL_TYPE_GPS: switch is on a GPS device.
+ * @RFKILL_TYPE_FM: switch is on a FM radio device.
+ * @NUM_RFKILL_TYPES: number of defined rfkill types
+ */
+enum rfkill_type {
+	RFKILL_TYPE_ALL = 0,
+	RFKILL_TYPE_WLAN,
+	RFKILL_TYPE_BLUETOOTH,
+	RFKILL_TYPE_UWB,
+	RFKILL_TYPE_WIMAX,
+	RFKILL_TYPE_WWAN,
+	RFKILL_TYPE_GPS,
+	RFKILL_TYPE_FM,
+	NUM_RFKILL_TYPES,
+};
+
+/**
+ * enum rfkill_operation - operation types
+ * @RFKILL_OP_ADD: a device was added
+ * @RFKILL_OP_DEL: a device was removed
+ * @RFKILL_OP_CHANGE: a device's state changed -- userspace changes one device
+ * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)
+ */
+enum rfkill_operation {
+	RFKILL_OP_ADD = 0,
+	RFKILL_OP_DEL,
+	RFKILL_OP_CHANGE,
+	RFKILL_OP_CHANGE_ALL,
+};
+
+/**
+ * struct rfkill_event - events for userspace on /dev/rfkill
+ * @idx: index of dev rfkill
+ * @type: type of the rfkill struct
+ * @op: operation code
+ * @hard: hard state (0/1)
+ * @soft: soft state (0/1)
+ *
+ * Structure used for userspace communication on /dev/rfkill,
+ * used for events from the kernel and control to the kernel.
+ */
+struct rfkill_event {
+	__u32 idx;
+	__u8  type;
+	__u8  op;
+	__u8  soft, hard;
+} __attribute__((packed));
+
+/*
+ * We are planning to be backward and forward compatible with changes
+ * to the event struct, by adding new, optional, members at the end.
+ * When reading an event (whether the kernel from userspace or vice
+ * versa) we need to accept anything that's at least as large as the
+ * version 1 event size, but might be able to accept other sizes in
+ * the future.
+ *
+ * One exception is the kernel -- we already have two event sizes in
+ * that we've made the 'hard' member optional since our only option
+ * is to ignore it anyway.
+ */
+#define RFKILL_EVENT_SIZE_V1	8
+
+/* ioctl for turning off rfkill-input (if present) */
+#define RFKILL_IOC_MAGIC	'R'
+#define RFKILL_IOC_NOINPUT	1
+#define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)
+
+/* and that's all userspace gets */
+
+#endif /* RFKILL_H */
